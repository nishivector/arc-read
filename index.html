<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Arc Read</title>
<script src="https://cdn.jsdelivr.net/npm/tone@15.1.22/build/Tone.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.183.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.0/examples/jsm/"
  }
}
</script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #7A3060; overflow: hidden; touch-action: none; font-family: 'Courier New', monospace; }
  #threeCanvas {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; touch-action: none;
  }
  #overlay2d {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 2;
  }
  #hud {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 3;
  }
  #startScreen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 10; display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: transparent;
  }
  #instructScreen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 10; display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: rgba(122, 48, 96, 0.92);
    display: none;
  }
  .corner-bracket {
    position: fixed; width: 32px; height: 32px;
    pointer-events: none; z-index: 10;
    border-color: rgba(240, 235, 216, 0.35);
    border-style: solid;
    transition: all 0.3s ease;
  }
  #cb-tl { top: 20px; left: 20px; border-width: 2px 0 0 2px; }
  #cb-tr { top: 20px; right: 20px; border-width: 2px 2px 0 0; }
  #cb-bl { bottom: 20px; left: 20px; border-width: 0 0 2px 2px; }
  #cb-br { bottom: 20px; right: 20px; border-width: 0 2px 2px 0; }
  .corner-bracket.animate-in { width: 0; height: 0; opacity: 0; }
  #titleSvg {
    margin-bottom: 16px;
    animation: titlePulse 2.5s ease-in-out infinite;
  }
  @keyframes titlePulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
  }
  #tagline {
    color: rgba(240, 235, 216, 0.6);
    font-size: clamp(14px, 3.5vw, 22px); letter-spacing: 0.2em; text-transform: uppercase;
    margin-bottom: 40px; font-family: 'Courier New', monospace;
  }
  #clickPrompt {
    color: #4DFFD6;
    font-size: clamp(13px, 3vw, 18px); letter-spacing: 0.3em; text-transform: uppercase;
    animation: blink 1s step-end infinite;
    font-family: 'Courier New', monospace;
  }
  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
  /* HUD elements */
  #hudWave {
    position: absolute; top: 20px; left: 20px;
    color: #F0EBD8; font-size: 14px; letter-spacing: 0.2em;
    font-family: 'Courier New', monospace;
  }
  #hudScore {
    position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
    color: #F0EBD8; font-size: 14px; letter-spacing: 0.2em;
    font-family: 'Courier New', monospace;
    transition: transform 0.2s ease;
  }
  #hudHealth {
    position: absolute; bottom: 20px; left: 20px;
    display: flex; flex-direction: column; gap: 6px;
  }
  #hudHealthLabel {
    color: #F0EBD8; font-size: clamp(13px, 3vw, 16px); letter-spacing: 0.2em;
    font-family: 'Courier New', monospace;
  }
  #hudHealthPips { display: flex; gap: 5px; }
  .healthPip {
    width: 14px; height: 14px;
    background: #F0EBD8;
    transition: background 0.3s, opacity 0.3s;
  }
  .healthPip.lost { background: transparent; border: 1px solid rgba(240,235,216,0.2); }
  #hudAmmo {
    position: absolute; bottom: 20px; right: 20px;
    display: flex; flex-direction: column; align-items: flex-end; gap: 6px;
  }
  #hudAmmoLabel {
    color: #F0EBD8; font-size: clamp(13px, 3vw, 16px); letter-spacing: 0.2em;
    font-family: 'Courier New', monospace;
  }
  #hudAmmoPips { display: flex; gap: 5px; }
  .ammoPip {
    width: 14px; height: 14px;
    clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
    background: #4DFFD6;
    filter: drop-shadow(0 0 4px #4DFFD6);
    transition: transform 0.15s ease, opacity 0.15s ease;
  }
  .ammoPip.spent { background: transparent; outline: 1px solid rgba(77,255,214,0.3); opacity: 0.3; filter: none; }
  #gameOverScreen, #winScreen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 20; display: none; flex-direction: column;
    align-items: center; justify-content: center;
    background: transparent;
  }
  #gameOverScreen.show, #winScreen.show { display: flex; }
  .endTitle {
    font-family: 'Courier New', monospace;
    font-size: clamp(22px, 6vw, 36px); letter-spacing: 0.3em; margin-bottom: 30px;
  }
  .endPrompt {
    color: #4DFFD6; font-size: clamp(14px, 3.5vw, 20px); letter-spacing: 0.3em;
    font-family: 'Courier New', monospace;
    animation: blink 1s step-end infinite;
    cursor: pointer; pointer-events: all;
  }
  #instructContent {
    max-width: 600px; text-align: center; padding: 40px;
  }
  #instructTitle {
    color: #4DFFD6; font-size: clamp(16px, 4.5vw, 24px); letter-spacing: 0.3em;
    margin-bottom: 24px; font-family: 'Courier New', monospace;
  }
  .instructLine {
    color: #F0EBD8; font-size: clamp(13px, 3vw, 16px); margin-bottom: 12px;
    font-family: 'Courier New', monospace; letter-spacing: 0.1em;
    opacity: 0.85;
  }
  .instructLine.accent { color: #4DFFD6; }
  #instructBtn {
    margin-top: 30px; color: #4DFFD6;
    font-size: clamp(13px, 3vw, 18px); letter-spacing: 0.3em;
    font-family: 'Courier New', monospace;
    cursor: pointer; pointer-events: all;
    animation: blink 1s step-end infinite;
  }
  #fadeOverlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: black; opacity: 0; z-index: 25; pointer-events: none;
    transition: opacity 0.3s ease;
  }
  #waveFlash {
    position: absolute; top: 20px; left: 20px;
    color: #4DFFD6;
  }
</style>
</head>
<body>

<!-- Three.js bg canvas -->
<canvas id="threeCanvas"></canvas>

<!-- 2D overlay for all game drawing -->
<canvas id="overlay2d"></canvas>

<!-- HUD layer -->
<div id="hud" style="display:none;">
  <div id="hudWave">WAVE 01</div>
  <div id="hudScore">0</div>
  <div id="hudHealth">
    <div id="hudHealthLabel">CITY</div>
    <div id="hudHealthPips"></div>
  </div>
  <div id="hudAmmo">
    <div id="hudAmmoLabel">ARCS</div>
    <div id="hudAmmoPips"></div>
  </div>
</div>

<!-- Start Screen -->
<div id="startScreen">
  <svg id="titleSvg" width="500" height="80" viewBox="0 0 500 80" xmlns="http://www.w3.org/2000/svg" style="width:42vw; height:auto;">
    <defs>
      <filter id="glowA" x="-30%" y="-30%" width="160%" height="160%">
        <feGaussianBlur stdDeviation="3" result="blur1"/>
        <feGaussianBlur stdDeviation="8" result="blur2"/>
        <feMerge><feMergeNode in="blur2"/><feMergeNode in="blur1"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    </defs>
    <text x="250" y="60" text-anchor="middle" font-family="'Courier New', monospace"
      font-size="72" font-weight="bold" fill="#F0EBD8" filter="url(#glowA)" letter-spacing="12">
      ARC READ
    </text>
  </svg>
  <div id="tagline">Draw where they will be.</div>
  <div id="clickPrompt">CLICK TO BEGIN</div>
</div>

<!-- Corner brackets -->
<div class="corner-bracket" id="cb-tl"></div>
<div class="corner-bracket" id="cb-tr"></div>
<div class="corner-bracket" id="cb-bl"></div>
<div class="corner-bracket" id="cb-br"></div>

<!-- Instructions Screen -->
<div id="instructScreen">
  <div id="instructContent">
    <div id="instructTitle">— HOW TO PLAY —</div>
    <div class="instructLine">Enemy formations descend toward your city.</div>
    <div class="instructLine accent">You cannot aim. You must <em>predict</em>.</div>
    <div class="instructLine" style="margin-top:16px;">DRAG from the city (bottom zone) to where</div>
    <div class="instructLine">an enemy <em>will be</em> when your arc arrives.</div>
    <div class="instructLine accent">Release to fire. The arc cannot be corrected.</div>
    <div class="instructLine" style="margin-top:16px;">6 interceptors per wave. Max 3 in-flight.</div>
    <div class="instructLine">Enemies reaching city = 1 damage. 5 lives total.</div>
    <div class="instructLine accent" style="margin-top:16px;">5 waves. Hold the line.</div>
    <div id="instructBtn">TAP TO START →</div>
  </div>
</div>

<!-- Game Over Screen -->
<div id="gameOverScreen">
  <div class="endTitle" style="color: rgba(240,235,216,0.5);">CITY LOST</div>
  <div class="endPrompt" id="tryAgainBtn">TRY AGAIN</div>
</div>

<!-- Win Screen -->
<div id="winScreen">
  <div class="endTitle" style="color: #4DFFD6;">CITY SURVIVED</div>
  <div id="winScore" style="color:#F0EBD8; font-size:clamp(14px, 3.5vw, 20px); letter-spacing:0.2em; margin-bottom:20px; font-family:'Courier New',monospace;"></div>
  <div class="endPrompt" id="playAgainBtn">PLAY AGAIN</div>
</div>

<!-- Fade overlay -->
<div id="fadeOverlay"></div>

<script type="module">
import * as THREE from 'three';

// ─── GLOBAL STATE ───────────────────────────────────────────────────────────
const W = () => window.innerWidth;
const H = () => window.innerHeight;

let gameState = 'start'; // start | instructions | game | gameover | win
let score = 0;
let cityHp = 5;
let currentWave = 0;
let ammoUsed = 0;
let ammoInFlight = 0;
const MAX_AMMO = 6;
const MAX_INFLIGHT = 3;
let waveDamage = false; // track if wave took no damage
let waveEnemiesTotal = 0;
let waveEnemiesKilled = 0;
let waveClearing = false;
let waveActive = false;

// Enemies, interceptors, particles
let enemies = [];
let interceptors = [];
let particles = [];
let cityBlocks = [];
let buildingLights = [];

// Dragging state
let isDragging = false;
let dragOriginX = 0, dragOriginY = 0;
let dragCursorX = 0, dragCursorY = 0;

// Timing
let lastTime = 0;
let waveTimer = 0;
let waveSpawnQueue = [];

// Audio
let audioReady = false;
let layerA_synth, layerB_part, layerB_loop, layerBGain;
let layerCKick, layerDStrings;
let arcDrawOsc;
let arcDrawGain;
let sfxLaunched = false;

// ─── THREE.JS SETUP ─────────────────────────────────────────────────────────
const canvas3d = document.getElementById('threeCanvas');
const renderer = new THREE.WebGLRenderer({ canvas: canvas3d, antialias: true });
renderer.setSize(W(), H());
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x7A3060);

const camera = new THREE.PerspectiveCamera(50, W() / H(), 0.1, 2000);
camera.position.set(0, 520, 280);
camera.lookAt(0, 0, 0);

// Ambient light for scene
const ambientLight = new THREE.AmbientLight(0x7A3060, 0.5);
scene.add(ambientLight);

// ─── 2D OVERLAY CANVAS ──────────────────────────────────────────────────────
const overlay = document.getElementById('overlay2d');
let ctx = null;

function resizeOverlay() {
  overlay.width = W();
  overlay.height = H();
}

function initOverlay() {
  ctx = overlay.getContext ? overlay.getContext('2d') : null;
  resizeOverlay();
}

// ─── PROCEDURAL CITY (SEED=42) ─────────────────────────────────────────────
function seededRand(seed) {
  let s = seed;
  return () => {
    s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
    return (s >>> 0) / 0xFFFFFFFF;
  };
}

function generateCity() {
  const rand = seededRand(42);
  cityBlocks = [];
  buildingLights = [];

  const cw = W();
  const ch = H();
  const cityY = ch * 0.87;

  const numBuildings = Math.floor(rand() * 7) + 18; // 18-24
  const blockCount = 3;
  const blockWidth = cw * 0.85 / blockCount;
  const startX = cw * 0.075;

  let bi = 0;
  for (let block = 0; block < blockCount; block++) {
    const bx = startX + block * blockWidth;
    const gap = rand() * 20 + 10;
    const buildingsInBlock = Math.floor(numBuildings / blockCount) + (block === 0 ? numBuildings % blockCount : 0);

    let x = bx + gap;
    for (let b = 0; b < buildingsInBlock; b++, bi++) {
      const bw = rand() * 30 + 20;
      const bh = rand() * 62 + 28;
      const building = { x, y: cityY - bh, w: bw, h: bh, lit: true, originalH: bh };
      cityBlocks.push(building);

      // Windows
      const cols = Math.floor(bw / 8);
      const rows = Math.floor(bh / 10);
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (rand() < 0.65) {
            buildingLights.push({
              x: x + c * 8 + 2,
              y: cityY - bh + r * 10 + 3,
              on: rand() < 0.8,
              flickerTimer: rand() * 8,
              flickerRate: rand() * 0.5 + 0.05,
              buildingIdx: bi
            });
          }
        }
      }

      x += bw + rand() * 8 + 2;
      if (x > bx + blockWidth - gap) break;
    }
  }
}

// ─── WAVE DEFINITIONS ───────────────────────────────────────────────────────
function makeWaveQueue(waveNum) {
  const cw = W(), ch = H();
  const scaleX = cw / 1280;
  const scaleY = ch / 720;
  const queue = [];

  const cruiserSpeed = 72 * scaleY;
  const fighterSpeed = 148 * scaleY;
  const interceptorSpeed = 230 * scaleY;
  const bomberSpeed = 72 * scaleY;

  if (waveNum === 1) {
    for (let i = 0; i < 4; i++) {
      queue.push({
        delay: i * 3000,
        type: 'cruiser',
        x: cw * 0.2 + i * cw * 0.2,
        y: -20,
        vx: 0, vy: cruiserSpeed,
        special: 'wave1bounce'
      });
    }
  } else if (waveNum === 2) {
    for (let i = 0; i < 3; i++) {
      queue.push({
        delay: i * 2200,
        type: 'cruiser',
        x: cw * 0.25 + i * cw * 0.25,
        y: -20,
        vx: 0, vy: cruiserSpeed
      });
    }
    const cornerAngles = [-20, -10, 10, 20];
    for (let i = 0; i < 4; i++) {
      const fromLeft = i < 2;
      const angle = (fromLeft ? 20 : -20) * Math.PI / 180;
      queue.push({
        delay: 1100 + i * 2200,
        type: 'fighter',
        x: fromLeft ? cw * 0.05 + i * cw * 0.05 : cw * 0.95 - (i - 2) * cw * 0.05,
        y: -20,
        vx: Math.sin(angle) * fighterSpeed,
        vy: Math.cos(angle) * fighterSpeed
      });
    }
  } else if (waveNum === 3) {
    // Formation A: V-formation 3 fighters
    const vCenter = cw * 0.5;
    queue.push({ delay: 0, type: 'fighter', x: vCenter, y: -20, vx: 0, vy: fighterSpeed });
    queue.push({ delay: 0, type: 'fighter', x: vCenter - 60 * scaleX, y: -20 - 30, vx: 0, vy: fighterSpeed });
    queue.push({ delay: 0, type: 'fighter', x: vCenter + 60 * scaleX, y: -20 - 30, vx: 0, vy: fighterSpeed });
    // Formation B: 2 Cruisers side by side
    queue.push({ delay: 4000, type: 'cruiser', x: cw * 0.4, y: -20, vx: 0, vy: cruiserSpeed });
    queue.push({ delay: 4000, type: 'cruiser', x: cw * 0.6, y: -20, vx: 0, vy: cruiserSpeed });
    // Formation C: Converge fighters
    queue.push({ delay: 7000, type: 'fighter', x: cw * 0.05, y: -20, vx: fighterSpeed * 0.4, vy: fighterSpeed * 0.9 });
    queue.push({ delay: 7000, type: 'fighter', x: cw * 0.95, y: -20, vx: -fighterSpeed * 0.4, vy: fighterSpeed * 0.9 });
  } else if (waveNum === 4) {
    queue.push({ delay: 0, type: 'interceptor', x: cw * 0.35, y: -20, vx: 0, vy: interceptorSpeed });
    queue.push({ delay: 0, type: 'interceptor', x: cw * 0.65, y: -20, vx: 0, vy: interceptorSpeed });
    queue.push({ delay: 4000, type: 'fighter', x: cw * 0.3, y: -20, vx: 0, vy: fighterSpeed });
    queue.push({ delay: 4000, type: 'fighter', x: cw * 0.5, y: -20, vx: 0, vy: fighterSpeed });
    queue.push({ delay: 4000, type: 'fighter', x: cw * 0.7, y: -20, vx: 0, vy: fighterSpeed });
    queue.push({ delay: 8000, type: 'cruiser', x: cw * 0.4, y: -20, vx: 0, vy: cruiserSpeed });
    queue.push({ delay: 8000, type: 'cruiser', x: cw * 0.6, y: -20, vx: 0, vy: cruiserSpeed });
  } else if (waveNum === 5) {
    // Bombers from top corners
    const angleL = 25 * Math.PI / 180;
    const angleR = -25 * Math.PI / 180;
    queue.push({ delay: 0, type: 'bomber', x: cw * 0.1, y: -20, vx: Math.sin(angleL) * bomberSpeed, vy: Math.cos(angleL) * bomberSpeed, missileReady: false, missileFired: false });
    queue.push({ delay: 0, type: 'bomber', x: cw * 0.9, y: -20, vx: Math.sin(angleR) * bomberSpeed, vy: Math.cos(angleR) * bomberSpeed, missileReady: false, missileFired: false });
    // Fighters
    queue.push({ delay: 5000, type: 'fighter', x: cw * 0.4, y: -20, vx: 0, vy: fighterSpeed });
    queue.push({ delay: 5000, type: 'fighter', x: cw * 0.6, y: -20, vx: 0, vy: fighterSpeed });
    // Interceptor class
    queue.push({ delay: 9000, type: 'interceptor', x: cw * 0.15, y: -20, vx: interceptorSpeed * 0.2, vy: interceptorSpeed });
  }

  waveEnemiesTotal = queue.length;
  waveEnemiesKilled = 0;
  return queue.map(e => ({ ...e, spawned: false }));
}

function spawnEnemy(def) {
  const scaleX = W() / 1280, scaleY = H() / 720;
  const e = {
    type: def.type,
    x: def.x,
    y: def.y,
    vx: def.vx || 0,
    vy: def.vy || 0,
    hp: 1,
    alive: true,
    special: def.special || null,
    missileReady: def.missileReady || false,
    missileFired: def.missileFired || false,
    missileWindup: 0,
    armed: false,
    wanderTimer: 0,
    wanderX: 0,
    id: Math.random()
  };
  enemies.push(e);
  return e;
}

// ─── BEZIER ARC MATH ────────────────────────────────────────────────────────
function getBezierControl(x0, y0, x1, y1) {
  const mx = (x0 + x1) / 2;
  const my = (y0 + y1) / 2;
  const dx = x1 - x0, dy = y1 - y0;
  const chordLength = Math.sqrt(dx * dx + dy * dy);
  // Perpendicular leftward bow — proportional to chord length
  const px = -dy / (chordLength || 1), py = dx / (chordLength || 1);
  const bow = chordLength * 0.18;
  return { cx: mx + px * bow, cy: my + py * bow };
}

function bezierPoint(t, x0, y0, cx, cy, x1, y1) {
  const mt = 1 - t;
  return {
    x: mt * mt * x0 + 2 * mt * t * cx + t * t * x1,
    y: mt * mt * y0 + 2 * mt * t * cy + t * t * y1
  };
}

function bezierLength(x0, y0, cx, cy, x1, y1, steps = 20) {
  let len = 0;
  let prev = bezierPoint(0, x0, y0, cx, cy, x1, y1);
  for (let i = 1; i <= steps; i++) {
    const p = bezierPoint(i / steps, x0, y0, cx, cy, x1, y1);
    const d = Math.hypot(p.x - prev.x, p.y - prev.y);
    len += d;
    prev = p;
  }
  return len;
}

// ─── INTERCEPTOR FIRING ─────────────────────────────────────────────────────
function fireInterceptor(ox, oy, tx, ty) {
  if (ammoUsed >= MAX_AMMO || ammoInFlight >= MAX_INFLIGHT) {
    // Shake + orange flash
    shakeDragPreview();
    return;
  }
  const { cx, cy } = getBezierControl(ox, oy, tx, ty);
  const totalLen = bezierLength(ox, oy, cx, cy, tx, ty);
  const speed = 520 * (H() / 720);

  const intp = {
    x0: ox, y0: oy, cx, cy, x1: tx, y1: ty,
    t: 0,
    totalLen,
    speed,
    alive: true,
    trail: [],
    id: Math.random()
  };
  interceptors.push(intp);
  ammoUsed++;
  ammoInFlight++;
  updateAmmoHUD();
  playLaunchThwip();
}

let shakeActive = false;
let shakeTimer = 0;
function shakeDragPreview() {
  shakeActive = true;
  shakeTimer = 200;
}

// ─── AUDIO SETUP ────────────────────────────────────────────────────────────
function initAudio() {
  try {
    // Layer A — Low brass cluster (always present)
    layerA_synth = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: 'sawtooth' },
      envelope: { attack: 2, decay: 0.5, sustain: 0.9, release: 3 },
      volume: -12
    });
    const reverbA = new Tone.Reverb({ decay: 4, wet: 0.6 });
    layerA_synth.connect(reverbA);
    reverbA.toDestination();
    layerA_synth.triggerAttack(['Bb2', 'F3', 'Ab3']);

    // Layer B — Sparse high synth
    layerBGain = new Tone.Gain(-18).toDestination();
    const layerBSynth = new Tone.Synth({
      oscillator: { type: 'sine' },
      envelope: { attack: 0.05, decay: 0.3, sustain: 0.6, release: 0.5 },
      volume: 0
    });
    const lfo = new Tone.LFO({ type: 'triangle', frequency: 0.25, min: -8, max: 8 }).start();
    const pitchShift = new Tone.PitchShift(0);
    lfo.connect(pitchShift.pitch);
    layerBSynth.connect(pitchShift);
    pitchShift.connect(layerBGain);

    const layerBNotes = ['Bb4', 'Db5', 'Ab4', 'Eb5'];
    let noteIdx = 0;
    layerB_loop = new Tone.Loop((time) => {
      if (Math.random() < 0.3) {
        layerBSynth.triggerAttackRelease(layerBNotes[noteIdx % 4], '8n', time);
        noteIdx++;
      }
    }, '4n').start(0);

    Tone.Transport.bpm.value = 92;
    Tone.Transport.start();

    // Arc draw oscillator
    arcDrawGain = new Tone.Gain(-24).toDestination();
    arcDrawOsc = new Tone.Oscillator({ type: 'sawtooth', frequency: 200 });
    arcDrawOsc.connect(arcDrawGain);

    audioReady = true;
  } catch(e) {
    // Audio failed silently
  }
}

function setMusicState(state) {
  if (!audioReady) return;
  try {
    if (state === 'menu') {
      layerA_synth.volume.rampTo(-12, 1);
      layerBGain.gain.rampTo(Tone.dbToGain(-18), 1);
    } else if (state === 'wave') {
      layerA_synth.volume.rampTo(-8, 2);
      layerBGain.gain.rampTo(Tone.dbToGain(-12), 2);
    } else if (state === 'danger') {
      layerA_synth.volume.rampTo(-6, 0.5);
    } else if (state === 'waveclear') {
      layerA_synth.volume.rampTo(-30, 0.5);
      layerBGain.gain.rampTo(Tone.dbToGain(-30), 0.5);
    } else if (state === 'wave5') {
      layerA_synth.volume.rampTo(-3, 2);
      layerBGain.gain.rampTo(Tone.dbToGain(-8), 2);
    }
  } catch(e) {}
}

function startArcDraw(arcLength) {
  if (!audioReady) return;
  try {
    const freq = 200 + (arcLength / (W() * 0.7)) * 400;
    arcDrawOsc.frequency.value = Math.max(200, Math.min(600, freq));
    arcDrawOsc.start();
  } catch(e) {}
}

function stopArcDraw() {
  if (!audioReady) return;
  try { arcDrawOsc.stop(); } catch(e) {}
}

function updateArcDrawFreq(arcLength) {
  if (!audioReady) return;
  try {
    const freq = 200 + (arcLength / (W() * 0.7)) * 400;
    arcDrawOsc.frequency.rampTo(Math.max(200, Math.min(600, freq)), 0.05);
  } catch(e) {}
}

function playLaunchThwip() {
  if (!audioReady) return;
  try {
    const noise = new Tone.NoiseSynth({ envelope: { attack: 0.001, decay: 0.008, sustain: 0, release: 0.01 }, volume: -10 });
    const hpf = new Tone.Filter(2000, 'highpass');
    noise.connect(hpf);
    hpf.toDestination();
    noise.triggerAttackRelease('8n');

    const sweep = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.05 }, volume: -14 });
    sweep.toDestination();
    sweep.triggerAttackRelease('D5', 0.08);
    setTimeout(() => { try { sweep.dispose(); noise.dispose(); hpf.dispose(); } catch(e) {} }, 500);
  } catch(e) {}
}

function playShipKill() {
  if (!audioReady) return;
  try {
    const n = new Tone.NoiseSynth({ envelope: { attack: 0.001, decay: 0.015, sustain: 0, release: 0.01 }, volume: -8 });
    n.toDestination();
    n.triggerAttackRelease('16n');
    const s = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.06, sustain: 0, release: 0.05 }, volume: -12 });
    s.toDestination();
    s.triggerAttackRelease('Bb1', 0.06);
    setTimeout(() => { try { n.dispose(); s.dispose(); } catch(e) {} }, 500);
  } catch(e) {}
}

function playMissileKill() {
  if (!audioReady) return;
  try {
    const sweep = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.001, decay: 0.04, sustain: 0, release: 0.02 }, volume: -10 });
    sweep.toDestination();
    sweep.triggerAttackRelease('D3', 0.04);
    setTimeout(() => {
      const n2 = new Tone.NoiseSynth({ envelope: { attack: 0.001, decay: 0.005, sustain: 0, release: 0.01 }, volume: -6 });
      n2.toDestination();
      n2.triggerAttackRelease('32n');
      const ring = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.12, sustain: 0.2, release: 0.1 }, volume: -12 });
      ring.toDestination();
      ring.triggerAttackRelease('B6', 0.12);
      setTimeout(() => { try { n2.dispose(); ring.dispose(); } catch(e) {} }, 600);
    }, 40);
    setTimeout(() => { try { sweep.dispose(); } catch(e) {} }, 300);
  } catch(e) {}
}

function playCityHit() {
  if (!audioReady) return;
  try {
    const bass = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.3, release: 0.2 }, volume: -6 });
    bass.toDestination();
    bass.triggerAttackRelease('G0', 0.3);
    const n = new Tone.NoiseSynth({ envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.05 }, volume: -12 });
    const lpf = new Tone.Filter(800, 'lowpass');
    n.connect(lpf);
    lpf.toDestination();
    n.triggerAttackRelease('4n');
    if (audioReady && layerA_synth) {
      layerA_synth.volume.rampTo(layerA_synth.volume.value - 4, 0.1);
      setTimeout(() => { try { layerA_synth.volume.rampTo(layerA_synth.volume.value + 4, 0.8); } catch(e) {} }, 100);
    }
    setTimeout(() => { try { bass.dispose(); n.dispose(); lpf.dispose(); } catch(e) {} }, 1000);
  } catch(e) {}
}

function playWaveClear() {
  if (!audioReady) return;
  try {
    setMusicState('waveclear');
    setTimeout(() => {
      const bell = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.6, sustain: 0, release: 0.3 }, volume: -8 });
      bell.toDestination();
      bell.triggerAttackRelease('Eb5', '4n');
      setTimeout(() => { try { bell.dispose(); } catch(e) {} }, 2000);
    }, 1500);
  } catch(e) {}
}

function playWaveStart() {
  if (!audioReady) return;
  try {
    const s = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 }, volume: -12 });
    s.toDestination();
    const beat = 60 / 92;
    s.triggerAttackRelease('Bb3', '8n');
    setTimeout(() => s.triggerAttackRelease('F4', '8n'), beat * 1000);
    setTimeout(() => s.triggerAttackRelease('Bb4', '8n'), beat * 2000);
    setTimeout(() => { try { s.dispose(); } catch(e) {} }, 3000);
  } catch(e) {}
}

function playBell() {
  if (!audioReady) return;
  try {
    const bell = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.6, sustain: 0, release: 0.3 }, volume: -8 });
    bell.toDestination();
    bell.triggerAttackRelease('Eb5', '4n');
    setTimeout(() => bell.triggerAttackRelease('Eb5', '4n'), 800);
    setTimeout(() => { try { bell.dispose(); } catch(e) {} }, 3000);
  } catch(e) {}
}

// ─── HUD MANAGEMENT ─────────────────────────────────────────────────────────
function buildHUD() {
  const hpContainer = document.getElementById('hudHealthPips');
  hpContainer.innerHTML = '';
  for (let i = 0; i < 5; i++) {
    const pip = document.createElement('div');
    pip.className = 'healthPip' + (i >= cityHp ? ' lost' : '');
    pip.id = 'hp' + i;
    hpContainer.appendChild(pip);
  }
  const ammoContainer = document.getElementById('hudAmmoPips');
  ammoContainer.innerHTML = '';
  for (let i = 0; i < MAX_AMMO; i++) {
    const pip = document.createElement('div');
    pip.className = 'ammoPip' + (i < ammoUsed ? ' spent' : '');
    pip.id = 'ammo' + i;
    ammoContainer.appendChild(pip);
  }
  document.getElementById('hudScore').textContent = score;
  document.getElementById('hudWave').textContent = 'WAVE 0' + currentWave;
}

function updateHealthHUD() {
  for (let i = 0; i < 5; i++) {
    const pip = document.getElementById('hp' + i);
    if (!pip) continue;
    if (i < cityHp) {
      pip.classList.remove('lost');
    } else {
      pip.classList.add('lost');
    }
  }
  if (cityHp <= 1) {
    // Pulse orange on remaining pips
    const pips = document.querySelectorAll('.healthPip:not(.lost)');
    pips.forEach(p => {
      p.style.animation = 'critPulse 0.1s ease-in-out infinite';
    });
    if (!document.getElementById('critStyle')) {
      const st = document.createElement('style');
      st.id = 'critStyle';
      st.textContent = `@keyframes critPulse { 0%,100%{background:#FF6B35} 50%{background:#F0EBD8} }`;
      document.head.appendChild(st);
    }
  }
}

function updateAmmoHUD() {
  for (let i = 0; i < MAX_AMMO; i++) {
    const pip = document.getElementById('ammo' + i);
    if (!pip) continue;
    if (i < ammoUsed) {
      pip.classList.add('spent');
    } else {
      pip.classList.remove('spent');
    }
  }
}

function popScore(points) {
  score += points;
  const el = document.getElementById('hudScore');
  el.textContent = score;
  el.style.transform = 'translateX(-50%) scale(1.15)';
  setTimeout(() => { el.style.transform = 'translateX(-50%) scale(1)'; }, 200);
}

function flashWave() {
  const el = document.getElementById('hudWave');
  el.style.color = '#4DFFD6';
  el.textContent = 'WAVE 0' + currentWave;
  setTimeout(() => { el.style.color = '#F0EBD8'; }, 400);
  setTimeout(() => { el.style.color = '#4DFFD6'; }, 700);
  setTimeout(() => { el.style.color = '#F0EBD8'; }, 1000);
}

// ─── PARTICLE SYSTEM ────────────────────────────────────────────────────────
function spawnDetonation(x, y, isMissile) {
  // Expanding circle
  particles.push({ type: 'detonation', x, y, r: 0, maxR: 40, t: 0, dur: 180 + 80, isMissile });
  // Inner flash
  particles.push({ type: 'flash', x, y, t: 0, dur: 60 });
  if (isMissile) {
    for (let i = 0; i < 4; i++) {
      const angle = (Math.PI * 2 / 4) * i + Math.random() * 0.5;
      particles.push({
        type: 'scatter', x, y, t: 0, dur: 400,
        vx: Math.cos(angle) * 60,
        vy: Math.sin(angle) * 60,
        len: 15
      });
    }
  }
}

function spawnDeathBurst(x, y) {
  for (let i = 0; i < 8; i++) {
    const angle = (Math.PI * 2 / 8) * i;
    const len = 6 + Math.random() * 6;
    particles.push({
      type: 'deathLine', x, y, t: 0, dur: 300,
      ax: Math.cos(angle), ay: Math.sin(angle), len
    });
  }
}

function spawnMissFlash(x, y) {
  particles.push({ type: 'flash', x, y, t: 0, dur: 60 });
}

function spawnCityHit() {
  particles.push({ type: 'cityDamage', t: 0, dur: 400 });
}

// ─── DRAWING ─────────────────────────────────────────────────────────────────
let flickerTime = 0;
let cityDamageFlash = 0;

function drawCity() {
  const ch = H();
  const cityY = ch * 0.87;

  ctx.save();

  // City damage flash
  if (cityDamageFlash > 0) {
    ctx.globalAlpha = Math.min(1, cityDamageFlash / 200);
    ctx.fillStyle = '#FF6B35';
    ctx.fillRect(0, cityY - 10, W(), H() - cityY + 10);
    ctx.globalAlpha = 1;
    cityDamageFlash -= 16;
  }

  // Blocks
  for (let i = 0; i < cityBlocks.length; i++) {
    const b = cityBlocks[i];
    // Determine building lit status (goes dark as hp lost)
    const darkFraction = (5 - cityHp) / 5;
    const buildingDark = i < Math.floor(cityBlocks.length * darkFraction);

    if (buildingDark) {
      ctx.fillStyle = 'rgba(60, 20, 40, 0.8)';
    } else {
      ctx.fillStyle = '#F0EBD8';
    }
    ctx.fillRect(b.x, b.y, b.w, b.h);
  }

  // Windows
  for (const light of buildingLights) {
    const b = cityBlocks[light.buildingIdx];
    if (!b) continue;
    const darkFraction = (5 - cityHp) / 5;
    const buildingDark = light.buildingIdx < Math.floor(cityBlocks.length * darkFraction);
    if (buildingDark) continue;

    const flicker = Math.max(0.3, Math.sin(flickerTime * light.flickerRate * 2 * Math.PI));
    if (light.on) {
      ctx.globalAlpha = 0.9 * flicker;
      ctx.fillStyle = '#FFE8A0';
      ctx.fillRect(light.x, light.y, 6, 8);
    }
    ctx.globalAlpha = 1;
  }

  // City base line
  ctx.strokeStyle = '#F0EBD8';
  ctx.lineWidth = 2;
  ctx.globalAlpha = 0.4;
  ctx.beginPath();
  ctx.moveTo(0, cityY + 10);
  ctx.lineTo(W(), cityY + 10);
  ctx.stroke();
  ctx.globalAlpha = 1;

  ctx.restore();
}

function drawEnemies(dt) {
  const scaleRef = Math.min(W() / 1280, H() / 720);

  for (const e of enemies) {
    if (!e.alive) continue;
    ctx.save();
    ctx.translate(e.x, e.y);

    const angle = Math.atan2(e.vy, e.vx) - Math.PI / 2;
    if (e.type !== 'cruiser') ctx.rotate(angle);

    ctx.fillStyle = 'transparent';

    if (e.type === 'cruiser') {
      // Elongated rhombus
      const w = 28 * scaleRef, h = 14 * scaleRef;
      ctx.lineWidth = 2;
      ctx.shadowBlur = 8;
      ctx.shadowColor = '#F0EBD8';
      ctx.strokeStyle = '#F0EBD8';
      ctx.beginPath();
      ctx.moveTo(0, -h);
      ctx.lineTo(w / 2, 0);
      ctx.lineTo(0, h);
      ctx.lineTo(-w / 2, 0);
      ctx.closePath();
      ctx.stroke();
      // Engine glow dots
      ctx.shadowBlur = 18;
      ctx.shadowColor = '#4DFFD6';
      ctx.fillStyle = '#4DFFD6';
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.arc(-w / 4 + i * (w / 6), h * 0.6, 2 * scaleRef, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
    } else if (e.type === 'fighter') {
      // Arrowhead
      const w = 16 * scaleRef, h = 10 * scaleRef;
      ctx.lineWidth = 1.5;
      ctx.shadowBlur = 8;
      ctx.shadowColor = '#F0EBD8';
      ctx.strokeStyle = '#F0EBD8';
      ctx.beginPath();
      ctx.moveTo(0, -h);
      ctx.lineTo(w / 2, h);
      ctx.lineTo(0, h * 0.3);
      ctx.lineTo(-w / 2, h);
      ctx.closePath();
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else if (e.type === 'bomber') {
      // Wide delta
      const w = 36 * scaleRef, h = 20 * scaleRef;
      ctx.lineWidth = 2.5;
      const armedAlpha = e.armed ? 0.6 + 0.4 * Math.sin(flickerTime * 1.2 * 2 * Math.PI) : 1;
      ctx.strokeStyle = e.armed ? `rgba(255,107,53,${armedAlpha})` : '#F0EBD8';
      ctx.shadowBlur = 8;
      ctx.shadowColor = e.armed ? '#FF6B35' : '#F0EBD8';
      ctx.beginPath();
      ctx.moveTo(0, -h);
      ctx.lineTo(w / 2, h * 0.5);
      ctx.lineTo(w * 0.2, h);
      ctx.lineTo(-w * 0.2, h);
      ctx.lineTo(-w / 2, h * 0.5);
      ctx.closePath();
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else if (e.type === 'interceptor') {
      // Same as fighter but slightly larger
      const w = 12 * scaleRef, h = 8 * scaleRef;
      ctx.lineWidth = 1.5;
      ctx.shadowBlur = 8;
      ctx.shadowColor = '#F0EBD8';
      ctx.strokeStyle = '#F0EBD8';
      ctx.beginPath();
      ctx.moveTo(0, -h);
      ctx.lineTo(w / 2, h);
      ctx.lineTo(0, h * 0.2);
      ctx.lineTo(-w / 2, h);
      ctx.closePath();
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else if (e.type === 'missile') {
      // Dart
      ctx.restore();
      ctx.save();
      ctx.translate(e.x, e.y);
      const mAngle = Math.atan2(e.vy, e.vx) - Math.PI / 2;
      ctx.rotate(mAngle);
      const mw = 8 * scaleRef, mh = 4 * scaleRef;
      ctx.shadowBlur = 18;
      ctx.shadowColor = '#4DFFD6';
      ctx.fillStyle = '#4DFFD6';
      ctx.beginPath();
      ctx.moveTo(0, -mh);
      ctx.lineTo(mw / 2, mh);
      ctx.lineTo(-mw / 2, mh);
      ctx.closePath();
      ctx.fill();
      // Exhaust trail
      ctx.globalAlpha = 0.4;
      ctx.strokeStyle = '#4DFFD6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, mh);
      ctx.lineTo(0, mh + 12 * scaleRef);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    ctx.restore();
  }
}

function drawInterceptors() {
  const scaleRef = Math.min(W() / 1280, H() / 720);
  for (const intp of interceptors) {
    if (!intp.alive) continue;
    // Trail with cyan glow
    ctx.shadowBlur = 18;
    ctx.shadowColor = '#4DFFD6';
    for (let i = 0; i < intp.trail.length; i++) {
      const pt = intp.trail[i];
      const alpha = (i / intp.trail.length) * 1.0;
      ctx.globalAlpha = alpha * 0.8;
      ctx.strokeStyle = '#4DFFD6';
      ctx.lineWidth = 2;
      if (i > 0) {
        ctx.beginPath();
        ctx.moveTo(intp.trail[i - 1].x, intp.trail[i - 1].y);
        ctx.lineTo(pt.x, pt.y);
        ctx.stroke();
      }
    }
    ctx.globalAlpha = 1;

    // Current position - diamond with glow
    const cur = bezierPoint(intp.t, intp.x0, intp.y0, intp.cx, intp.cy, intp.x1, intp.y1);
    const s = 6 * scaleRef;
    ctx.fillStyle = '#4DFFD6';
    ctx.shadowBlur = 18;
    ctx.shadowColor = '#4DFFD6';
    ctx.save();
    ctx.translate(cur.x, cur.y);
    ctx.rotate(Math.PI / 4);
    ctx.fillRect(-s / 2, -s / 2, s, s);
    ctx.restore();
    ctx.shadowBlur = 0;
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function drawDragPreview() {
  if (!isDragging) return;
  const { cx, cy } = getBezierControl(dragOriginX, dragOriginY, dragCursorX, dragCursorY);
  const len = bezierLength(dragOriginX, dragOriginY, cx, cy, dragCursorX, dragCursorY);

  const noAmmo = ammoUsed >= MAX_AMMO || ammoInFlight >= MAX_INFLIGHT;
  const color = noAmmo ? '#FF6B35' : '#4DFFD6';

  let shakeOff = 0;
  if (shakeActive) {
    shakeOff = (Math.random() - 0.5) * 6;
  }

  ctx.save();
  ctx.setLineDash([6, 4]);
  ctx.strokeStyle = color;
  ctx.globalAlpha = 0.5;
  ctx.lineWidth = 2.5;
  ctx.shadowBlur = noAmmo ? 0 : 18;
  ctx.shadowColor = '#4DFFD6';
  ctx.beginPath();
  ctx.moveTo(dragOriginX + shakeOff, dragOriginY + shakeOff);

  // Draw dashed bezier using many segments
  const steps = 30;
  for (let i = 1; i <= steps; i++) {
    const pt = bezierPoint(i / steps, dragOriginX, dragOriginY, cx, cy, dragCursorX, dragCursorY);
    ctx.lineTo(pt.x + shakeOff, pt.y + shakeOff);
  }
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 1;
  ctx.restore();

  updateArcDrawFreq(len);
}

function drawParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.t += dt;
    if (p.t >= p.dur) { particles.splice(i, 1); continue; }

    const progress = p.t / p.dur;

    if (p.type === 'detonation') {
      const phaseGrow = 180 / p.dur;
      const r = progress < phaseGrow ? p.maxR * (p.t / 180) : p.maxR;
      const alpha = progress < phaseGrow ? 0.9 : Math.max(0, 1 - (p.t - 180) / 80);
      // Bloom layer: wide soft glow pass
      ctx.globalAlpha = alpha * 0.25;
      ctx.strokeStyle = '#4DFFD6';
      ctx.lineWidth = 6;
      ctx.shadowBlur = 18;
      ctx.shadowColor = '#4DFFD6';
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.stroke();
      // Sharp pass on top
      ctx.globalAlpha = alpha;
      ctx.lineWidth = 2;
      ctx.shadowBlur = 18;
      ctx.shadowColor = '#4DFFD6';
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    } else if (p.type === 'flash') {
      ctx.globalAlpha = 1 - progress;
      ctx.fillStyle = '#F0EBD8';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    } else if (p.type === 'scatter') {
      const alpha = 1 - progress;
      const x2 = p.x + p.vx * (p.t / 1000);
      const y2 = p.y + p.vy * (p.t / 1000);
      ctx.globalAlpha = alpha * 0.8;
      ctx.strokeStyle = '#4DFFD6';
      ctx.lineWidth = 2;
      ctx.shadowBlur = 18;
      ctx.shadowColor = '#4DFFD6';
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 + p.ax * p.len, y2 + p.ay * p.len);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    } else if (p.type === 'deathLine') {
      const alpha = 1 - progress;
      const dist = 12 * progress;
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#F0EBD8';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(p.x + p.ax * dist, p.y + p.ay * dist);
      ctx.lineTo(p.x + p.ax * (dist + p.len), p.y + p.ay * (dist + p.len));
      ctx.stroke();
      ctx.globalAlpha = 1;
    } else if (p.type === 'cityDamage') {
      cityDamageFlash = Math.max(cityDamageFlash, (1 - progress) * 400);
    } else if (p.type === 'missFlash') {
      ctx.globalAlpha = Math.max(0, 1 - progress * 8);
      ctx.fillStyle = '#F0EBD8';
      ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
      ctx.globalAlpha = 1;
    }
  }
}

// ─── START SCREEN IDLE ANIMATION ────────────────────────────────────────────
let idleShips = [];
let idleTime = 0;
let ghostArcs = [];
let ghostInterceptor = null;
let ghostTimer = 0;

function initIdleAnimation() {
  idleShips = [];
  const cw = W(), ch = H();
  const speed = 0.3;

  // 5 Cruisers
  for (let i = 0; i < 5; i++) {
    idleShips.push({
      type: 'cruiser',
      x: cw * 0.15 + i * cw * 0.17,
      y: -50 - Math.random() * 100,
      vx: 0,
      vy: 72 * speed * (ch / 720)
    });
  }
  // 3 Fighters
  for (let i = 0; i < 3; i++) {
    idleShips.push({
      type: 'fighter',
      x: cw * 0.2 + i * cw * 0.3,
      y: -80 - Math.random() * 150,
      vx: 0,
      vy: 148 * speed * (ch / 720)
    });
  }

  ghostTimer = 7000;
}

function updateIdleAnimation(dt) {
  idleTime += dt;
  const ch = H();

  for (const ship of idleShips) {
    ship.x += ship.vx * dt / 1000;
    ship.y += ship.vy * dt / 1000;
    if (ship.y > ch + 60) {
      ship.y = -60;
      ship.x = Math.random() * W();
    }
  }

  // Ghost arcs
  for (let i = ghostArcs.length - 1; i >= 0; i--) {
    ghostArcs[i].t += dt;
    if (ghostArcs[i].t > 4000) ghostArcs.splice(i, 1);
  }

  // Ghost interceptor
  ghostTimer -= dt;
  if (ghostTimer <= 0) {
    ghostTimer = 7000;
    if (!ghostInterceptor) {
      // Launch a ghost interceptor
      const cw = W(), cch = H();
      const target = idleShips[Math.floor(Math.random() * idleShips.length)];
      const ox = cw * 0.5, oy = cch * 0.88;
      const { cx, cy } = getBezierControl(ox, oy, target.x, target.y);
      const len = bezierLength(ox, oy, cx, cy, target.x, target.y);
      ghostInterceptor = { x0: ox, y0: oy, cx, cy, x1: target.x, y1: target.y, t: 0, totalLen: len, speed: 520 * 0.3 * ch / 720, trail: [] };
      ghostArcs.push({ x0: ox, y0: oy, cx, cy, x1: target.x, y1: target.y, t: 0 });
    }
  }

  if (ghostInterceptor) {
    const dist = ghostInterceptor.speed * dt / 1000;
    const dtParam = dist / (ghostInterceptor.totalLen || 1);
    ghostInterceptor.t = Math.min(1, ghostInterceptor.t + dtParam);
    const cur = bezierPoint(ghostInterceptor.t, ghostInterceptor.x0, ghostInterceptor.y0, ghostInterceptor.cx, ghostInterceptor.cy, ghostInterceptor.x1, ghostInterceptor.y1);
    ghostInterceptor.trail.push({ x: cur.x, y: cur.y });
    if (ghostInterceptor.trail.length > 20) ghostInterceptor.trail.shift();
    if (ghostInterceptor.t >= 1) ghostInterceptor = null;
  }
}

function drawIdleAnimation() {
  const scaleRef = Math.min(W() / 1280, H() / 720);

  // Draw ghost arc trails
  for (const arc of ghostArcs) {
    const prog = Math.min(1, arc.t / 2000);
    const fadeIn = Math.min(1, prog * 2);
    const fadeOut = Math.max(0, 1 - (prog - 0.5) * 2);
    const alpha = Math.min(fadeIn, fadeOut) * 0.15;
    if (alpha <= 0) continue;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = '#4DFFD6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(arc.x0, arc.y0);
    const steps = 20;
    for (let i = 1; i <= steps; i++) {
      const pt = bezierPoint(i / steps, arc.x0, arc.y0, arc.cx, arc.cy, arc.x1, arc.y1);
      ctx.lineTo(pt.x, pt.y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // Ghost interceptor
  if (ghostInterceptor) {
    ctx.shadowBlur = 18;
    ctx.shadowColor = '#4DFFD6';
    for (let i = 1; i < ghostInterceptor.trail.length; i++) {
      const alpha = (i / ghostInterceptor.trail.length) * 0.55;
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#4DFFD6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(ghostInterceptor.trail[i - 1].x, ghostInterceptor.trail[i - 1].y);
      ctx.lineTo(ghostInterceptor.trail[i].x, ghostInterceptor.trail[i].y);
      ctx.stroke();
    }
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }

  // Draw idle ships
  for (const ship of idleShips) {
    ctx.save();
    ctx.translate(ship.x, ship.y);
    ctx.strokeStyle = '#F0EBD8';
    ctx.globalAlpha = 0.7;

    if (ship.type === 'cruiser') {
      const w = 28 * scaleRef, h = 14 * scaleRef;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, -h);
      ctx.lineTo(w / 2, 0);
      ctx.lineTo(0, h);
      ctx.lineTo(-w / 2, 0);
      ctx.closePath();
      ctx.stroke();
      ctx.fillStyle = '#4DFFD6';
      ctx.shadowBlur = 18;
      ctx.shadowColor = '#4DFFD6';
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.arc(-w / 4 + i * (w / 6), h * 0.6, 2 * scaleRef, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
    } else if (ship.type === 'fighter') {
      const w = 16 * scaleRef, h = 10 * scaleRef;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(0, -h);
      ctx.lineTo(w / 2, h);
      ctx.lineTo(0, h * 0.3);
      ctx.lineTo(-w / 2, h);
      ctx.closePath();
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

// ─── GAME LOOP ───────────────────────────────────────────────────────────────
let animId = null;

function gameLoop(timestamp) {
  animId = requestAnimationFrame(gameLoop);
  const dt = Math.min(timestamp - lastTime, 50);
  lastTime = timestamp;

  // Clear overlay
  if (!ctx) return;
  ctx.clearRect(0, 0, W(), H());

  flickerTime += dt / 1000;

  if (gameState === 'start') {
    updateIdleAnimation(dt);
    drawIdleAnimation();
    drawCity();
    renderer.render(scene, camera);
    return;
  }

  if (gameState === 'instructions') {
    renderer.render(scene, camera);
    return;
  }

  if (gameState !== 'game' && gameState !== 'gameover' && gameState !== 'win' && gameState !== 'ending') {
    renderer.render(scene, camera);
    return;
  }

  if (gameState === 'game') {
    updateGame(dt);
  }

  drawCity();
  drawEnemies(dt);
  drawInterceptors();
  drawDragPreview();
  drawParticles(dt);

  if (shakeActive) {
    shakeTimer -= dt;
    if (shakeTimer <= 0) shakeActive = false;
  }

  renderer.render(scene, camera);
}

function updateGame(dt) {
  // Wave spawning
  waveTimer += dt;
  for (const entry of waveSpawnQueue) {
    if (!entry.spawned && waveTimer >= entry.delay) {
      entry.spawned = true;
      spawnEnemy(entry);
    }
  }

  const ch = H(), cw = W();
  const cityY = ch * 0.87;
  const scaleRef = Math.min(cw / 1280, ch / 720);

  // Update enemies
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (!e.alive) { enemies.splice(i, 1); continue; }

    // Fighter wander
    if (e.type === 'fighter') {
      e.wanderTimer -= dt;
      if (e.wanderTimer <= 0) {
        e.wanderTimer = 1200;
        e.wanderX = (Math.random() - 0.5) * 16;
      }
      e.x += e.wanderX * dt / 1200;
    }

    // Homing missile
    if (e.type === 'missile') {
      const cx = cw * 0.5, cy = cityY;
      const dx = cx - e.x, dy = cy - e.y;
      const desiredAngle = Math.atan2(dy, dx);
      const currentAngle = Math.atan2(e.vy, e.vx);
      let angleDiff = desiredAngle - currentAngle;
      while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
      while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
      const maxTurn = (90 * Math.PI / 180) * dt / 1000;
      const turn = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
      const newAngle = currentAngle + turn;
      const speed = 180 * (ch / 720);
      e.vx = Math.cos(newAngle) * speed;
      e.vy = Math.sin(newAngle) * speed;
    }

    // Bomber missile logic
    if (e.type === 'bomber' && !e.missileFired) {
      if (e.y > ch * 0.5) {
        e.missileWindup += dt;
        e.armed = true;
        if (e.missileWindup >= 1200) {
          e.missileFired = true;
          e.armed = false;
          // Spawn missile
          const mSpeed = 180 * (ch / 720);
          const dx = cw * 0.5 - e.x, dy = cityY - e.y;
          const dist = Math.hypot(dx, dy);
          enemies.push({
            type: 'missile', x: e.x, y: e.y,
            vx: (dx / dist) * mSpeed, vy: (dy / dist) * mSpeed,
            hp: 1, alive: true, id: Math.random()
          });
          waveEnemiesTotal++;
        }
      }
    }

    // Move
    e.x += e.vx * dt / 1000;
    e.y += e.vy * dt / 1000;

    // Wave 1 bounce
    if (e.special === 'wave1bounce' && e.y > ch * 0.82) {
      const speed = Math.abs(e.vy);
      if (speed < 15) {
        e.alive = false;
      } else {
        e.vy = -speed * 0.6;
        e.y = ch * 0.82 - 1;
      }
    }
    // Also remove if it bounces way off screen top
    if (e.special === 'wave1bounce' && e.y < -200) {
      e.alive = false;
    }

    // City hit
    if (e.y > cityY && e.special !== 'wave1bounce') {
      e.alive = false;
      cityHp = Math.max(0, cityHp - 1);
      waveDamage = true;
      updateHealthHUD();
      playCityHit();
      spawnCityHit();
      cityDamageFlash = 400;
      if (cityHp <= 0) {
        setTimeout(() => triggerGameOver(), 1500);
        gameState = 'ending';
        return;
      }
    }

    // Off screen sides (not city)
    if (e.x < -100 || e.x > cw + 100) {
      e.alive = false;
    }
  }

  // Danger music check
  const dangerThreshold = ch * 0.6 + ch * 0.12;
  const anyDanger = enemies.some(e => e.alive && e.y > dangerThreshold);
  if (anyDanger) {
    setMusicState('danger');
  }

  // Update interceptors
  for (let i = interceptors.length - 1; i >= 0; i--) {
    const intp = interceptors[i];
    if (!intp.alive) { interceptors.splice(i, 1); continue; }

    const dist = intp.speed * dt / 1000;
    const dtParam = dist / (intp.totalLen || 1);
    intp.t = Math.min(1, intp.t + dtParam);

    const cur = bezierPoint(intp.t, intp.x0, intp.y0, intp.cx, intp.cy, intp.x1, intp.y1);
    intp.trail.push({ x: cur.x, y: cur.y });
    if (intp.trail.length > 15) intp.trail.shift();

    // Hit detection
    let hit = false;
    for (const e of enemies) {
      if (!e.alive) continue;
      const d = Math.hypot(cur.x - e.x, cur.y - e.y);
      if (d < 18 * scaleRef) {
        // Kill
        e.alive = false;
        waveEnemiesKilled++;
        hit = true;
        spawnDetonation(cur.x, cur.y, e.type === 'missile');
        spawnDeathBurst(e.x, e.y);
        if (e.type === 'missile') {
          playMissileKill();
          popScore(250);
        } else {
          playShipKill();
          popScore(100);
        }
        break;
      }
    }

    if (intp.t >= 1 && !hit) {
      spawnMissFlash(cur.x, cur.y);
      hit = true; // treat as done
    }

    if (hit || intp.t >= 1) {
      intp.alive = false;
      ammoInFlight--;
    }
  }

  // Check wave complete
  checkWaveComplete(dt);
}

function checkWaveComplete(dt) {
  if (waveClearing) return;
  const allSpawned = waveSpawnQueue.every(e => e.spawned);
  const allDead = enemies.every(e => !e.alive);
  const ammoEmpty = ammoUsed >= MAX_AMMO && ammoInFlight === 0;

  if (allSpawned && (allDead || ammoEmpty)) {
    // Wave over
    waveClearing = true;
    const unused = MAX_AMMO - ammoUsed;
    popScore(unused * 50);
    if (!waveDamage) popScore(500);

    if (currentWave >= 5) {
      setTimeout(() => triggerWin(), 1000);
    } else {
      playWaveClear();
      setTimeout(() => startNextWave(), 4000);
    }
  }
}

function startNextWave() {
  currentWave++;
  enemies = [];
  interceptors = [];
  particles = [];
  ammoUsed = 0;
  ammoInFlight = 0;
  waveDamage = false;
  waveClearing = false;
  waveTimer = 0;
  waveSpawnQueue = makeWaveQueue(currentWave);

  buildHUD();
  flashWave();
  playWaveStart();

  if (currentWave === 5) setMusicState('wave5');
  else setMusicState('wave');
}

function triggerGameOver() {
  gameState = 'gameover';
  document.getElementById('hud').style.display = 'none';
  document.getElementById('gameOverScreen').classList.add('show');
  if (audioReady) {
    try { layerA_synth.volume.rampTo(-24, 1); } catch(e) {}
  }
}

function triggerWin() {
  gameState = 'win';
  document.getElementById('hud').style.display = 'none';
  document.getElementById('winScreen').classList.add('show');
  document.getElementById('winScore').textContent = 'SCORE: ' + score;
  playBell();
  setMusicState('waveclear');
}

// ─── INPUT HANDLING ──────────────────────────────────────────────────────────
function getPointerPos(e) {
  const rect = overlay.getBoundingClientRect();
  return {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
  };
}

function getNearestCityBlockCenter(x) {
  let best = null, bestDist = Infinity;
  for (const b of cityBlocks) {
    const cx = b.x + b.w / 2;
    const d = Math.abs(cx - x);
    if (d < bestDist) { bestDist = d; best = cx; }
  }
  return best || x;
}

// Pointer events on the body (not overlay, since overlay is pointer-events:none)
document.addEventListener('pointerdown', (e) => {
  if (gameState === 'start') {
    onStartClick(e);
    return;
  }
  if (gameState === 'instructions') return;
  if (gameState !== 'game') return;

  const pos = getPointerPos(e);
  const cityZoneY = H() * 0.85;

  if (pos.y >= cityZoneY) {
    isDragging = true;
    const snapX = getNearestCityBlockCenter(pos.x);
    dragOriginX = snapX;
    dragOriginY = pos.y;
    dragCursorX = pos.x;
    dragCursorY = pos.y;
    startArcDraw(0);
    e.preventDefault();
  }
});

document.addEventListener('pointermove', (e) => {
  if (!isDragging || gameState !== 'game') return;
  const pos = getPointerPos(e);
  dragCursorX = pos.x;
  dragCursorY = pos.y;
  e.preventDefault();
});

document.addEventListener('pointerup', (e) => {
  if (!isDragging || gameState !== 'game') return;
  isDragging = false;
  stopArcDraw();
  const pos = getPointerPos(e);
  dragCursorX = pos.x;
  dragCursorY = pos.y;
  fireInterceptor(dragOriginX, dragOriginY, dragCursorX, dragCursorY);
  e.preventDefault();
});

function onStartClick(e) {
  // Animate brackets inward
  ['cb-tl', 'cb-tr', 'cb-bl', 'cb-br'].forEach(id => {
    document.getElementById(id).classList.add('animate-in');
  });

  const fadeEl = document.getElementById('fadeOverlay');
  fadeEl.style.opacity = '1';

  setTimeout(() => {
    document.getElementById('startScreen').style.display = 'none';
    fadeEl.style.opacity = '0';
    document.getElementById('instructScreen').style.display = 'flex';
    gameState = 'instructions';
  }, 300);

  // Start audio on first interaction
  Tone.start().then(() => initAudio()).catch(() => {});
}

document.getElementById('instructBtn').addEventListener('pointerdown', (e) => {
  e.stopPropagation();
  if (gameState !== 'instructions') return;
  document.getElementById('instructScreen').style.display = 'none';
  startGame();
});

document.getElementById('tryAgainBtn').addEventListener('pointerdown', (e) => {
  e.stopPropagation();
  resetGame();
});

document.getElementById('playAgainBtn').addEventListener('pointerdown', (e) => {
  e.stopPropagation();
  resetGame();
});

function startGame() {
  gameState = 'game';
  score = 0;
  cityHp = 5;
  currentWave = 0;
  enemies = [];
  interceptors = [];
  particles = [];

  document.getElementById('hud').style.display = 'block';
  buildHUD();
  generateCity();

  startNextWave();
  setMusicState('wave');
}

function resetGame() {
  document.getElementById('gameOverScreen').classList.remove('show');
  document.getElementById('winScreen').classList.remove('show');
  waveClearing = false;
  startGame();
}

// ─── RESIZE ──────────────────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  renderer.setSize(W(), H());
  camera.aspect = W() / H();
  camera.fov = camera.aspect < 1 ? Math.min(50 / camera.aspect, 90) : 50;
  camera.updateProjectionMatrix();
  resizeOverlay();
  generateCity();
  if (gameState === 'game') buildHUD();
  if (gameState === 'start') initIdleAnimation();
});

// ─── INIT ────────────────────────────────────────────────────────────────────
initOverlay();
generateCity();
initIdleAnimation();
lastTime = performance.now();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
